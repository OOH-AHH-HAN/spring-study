# 인터넷 네트워크

## 인터넷 통신
- Web, Http는 모두 인터넷 망 기반이므로 인터넷 통신의 원리를 이해해야 함
- 인터넷에서 컴퓨터가 통신하는 방식
	+ 근거리 : 케이블로 연결해서 받으면 됨.
	+ 원거리 : 메세지 망을 통해서 주고 받음
		* 예) 한국에서 미국으로 보낼 떄
		* 인터넷을 통해서 전달하는데 인터넷은 수많은 노드(서버)로 구성되어 있기에 단순하지 않음
		* 규칙이 필요함

<br/>

## IP(인터넷 프로토콜)

- 클라이언트와 서버가 통신할 때는 IP주소를 부여받아야 함

- 역할
	+ 지정한 IP 주소(IP Address)에 데이터를 전달할 수 있도록 지정해놓은 규칙
	+ `패킷(Packet)`이라는 통신 단위로 데이터를 전달
- IP 패킷
	+ `일종의 규칙`
	+ 보내는 IP(출발지), 받는 IP(목적지)를 주소 적듯이 적고 전송 데이터를 적음
	+ 메세지를 그냥 보내는 것이 아니라 IP패킷이라는 규칙이 존재하는 것
- 패킷 전달
	+ 클라이언트 패킷 전달
		1. IP 패킷에 맞게 `출발 IP, 도착 IP, 전송할 메세지` 등을 적음
		2. 패킷이 `서버 규약`을 따라서 인터넷 안의 노드를 통해 전송됨
		3. 노드들이 도착 IP를 찾아서 `도달`하게 해줌
	+ 서버 패킷 전달
		1. IP 패킷에 맞게 `출발 IP, 도착 IP, 전송할 메세지` 등을 적음
		2. 패킷이 `서버 규약`을 따라서 인터넷 안의 노드를 통해 전송됨
		3. 노드들이 도착 IP를 찾아서 `도달`하게 해줌
	+ 클라이언트와 서버 패킷의 전달 방식은 동일하지만 인터넷 망이 복잡하기에 `서로 다른 노드`를 통해 전송될 수 있음
- 한계
	1. `비연결성`
		- 패킷을 받을 대상이 없을 수 있음
		- 패킷을 받을 대상이 서비스 불능 상태일 수 있음
		- 위의 경우임에도 확인 불가능하여 무조건 패킷 전송
	2. `비신뢰성`
		- 패킷이 중간에 소실될 수 있음
		- 전송하는 메세지가 대략 1500byte가 넘으면 한번에 보내기 부담스러워서 끊어서 보내는 경우가 생기는데 이 경우 패킷들이 서로 다른 노드를 타는 상황이 생기고 그로인해 패킷의 순서가 바뀔 수 있음
	3. `프로그램 구분 불가능`
		- 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 여러개라면 구분 불가능
> `TCP` : IP의 한계를 해결해줌

<br/>

## TCP
- 전송 제어 프로토콜(Transmission Control Protocol)
- 인터넷 프로토콜 스택의 4계층
	+ 위로 갈수록 밑의 계층 보완

	|계층|계층 이름|프로토콜|
	|:---:|:---:|:---:|
	|4|애플리케이션|HTTP, FTP|
	|3|   전송   |TCP, UDP|
	|2|  인터넷   |  IP    |
	|1| 네트워크 인터페이스 | LAN 등|

	<br/>

	<table>
 		<tr>
    		<td rowspan="2">애플리케이션</td>
    		<td>웹브라우저, 네트워크 게임, 채팅 프로그램</td>
  		</tr>
  		<tr>
    		<td>SOCKET 라이브러리</td>
  		</tr>
		<tr>
    		<td rowspan="2">OS</td>
    		<td>TCP</td>
  		</tr>
  		<tr>
    		<td>IP(Internet Protocol)</td>
  		</tr>
 		<tr>
    		<td>네트워크 인터페이스</td>
    		<td>LAN 드라이버, LAN 장비</td>
  		</tr>
	</table>

	1. 프로그램이 Hello, World! 메세지 생성
	2. `SOCKET 라이브러리`를 통해 전달
	3. `TCP 정보` 생성, 메세지 데이터 포함(TCP로 메세지 감쌈)
	4. `IP 패킷` 생성, TCP 데이터 포함(IP로 TCP 감쌈)
	5. Ethernet frame으로 감쌈 -> 물리적인 정보 포함

- IP 패킷 정보
	+ 패키지 + 버킷
	+ 택배박스에 데이터를 넣어서 보내는 것과 같음

- TCP/IP 패킷 정보
	+ 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등을 포함
	+ IP만으로 해결이 안됐던 문제들 해결

- 특징
	+ `연결지향`
		* `TCP 3wqy handshake(가상 연결)`
			- 진짜 연결은 아니고 개념적, 논리적으로만 연결
			- 연결이 되면 데이터 전송
			- 비연결성 해결
			- 순서
			 	1. 클라이언트가 `SYN(접속 요청)`를 서버에 보냄 - connect, 연결 확인
			 	2. 서버가 `ACK(요청 수락)`를 클라이언트에 보냄
			 	3. 클라이언트가 다시 `ACK`를 보낸 후 데이터를 전송함
					- `ACK`와 함께 데이터를 전송 가능
	+ `데이터 전달 보증`
		* 데이터를 전송하면 데이터를 잘 받았다는 응답을 보내줌
	+ `순서 보장`
		* 패킷1, 패킷2, 패킷3 순서로 전송했는데 패킷1, 패킷3, 패킷2 순서로 도착했다면 패킷2부터 다시 보내라는 응답이 옴
	+ 신뢰할 수 있는 프로토콜
	+ 현재는 대부분 TCP 사용
- `UDP`
	+ 사용자 데이터그램 프로토콜(User Datagram Protocol)
	+ 기능이 거의 없음
	+ 연결 지향 x
	+ 데이터 전달 보증 x
	+ 순서 보장 x
	+ 단순하고 빠름
	+ IP와 거의 같지만 PORT와 체크섬 추가
		* `PORT` : 하나의 IP에서 여러개의 애플리케이션을 운영할 때 구분
		* `체크섬` : 검증 데이터
	+ 애플리케이션에서 추가 작업 필요
	+ TCP는 처리 시간, 데이터 양 때문에 전송 속도가 느릴 수 있는데 이를 `최적화`할 때 사용
	+ 최근에 각광 받음

<br/>

## PORT
- 단어 뜻은 항구를 나타냄
- 하나의 클라이언트 서버가 여러 애플리케이션 서버와 통신해야 할 때 `패킷을 구분`할 수 있는 방법
- `TCP = IP + PORT`라고도 할 수 있음
- `애플리케이션을 구분 가능`
- 같은 IP 내에서 PORT를 다르게 부여하여 `프로세스를 구분`
- 종류
	+ 0 ~ 65535 : 할당 가능
	+ 0 ~ 1023 : 잘 알려진 포트, 사용하지 않는 것이 좋음		* FTP : 20, 21
		* TELNET : 23
		* `HTTP` : 80
		* HTTPS : 443

<br/>

## DNS
- `도메인 네임 시스템(Domain Name System)`
- IP는 기억하기 어렵고, 변경될 수 있는데 이런 문제점을 해결
- 전화번호부같은 서버를 제공
- 도메인 명을 IP 주소로 변환
	+ 도메인 명을 사서 `DNS 서버`에 등록해둠
	+ `도메인 명을 요청`하면 DNS 서버에서 `IP를 응답`해주고 그 IP로 접속















