# HTTP 메서드

## HTTP 메서드 설계
- 요구사항(회원 정보 관리 API)
	+ 회원 목록 조회
	+ 회원 조회
	+ 회원 등록
	+ 회원 수정
	+ 회원 삭제


### API URI 설계(Uniform Resource Identifier)
- `행위가 아닌 리소스를 식별해야 함!`
	+ `리소스란?`
		* 회원을 등록하고 수정하고 조회하는게 리소스가 아니라 회원이 리소스
	+ 리소스 식별 방법
		* 회원을 등록하고 수정하고 조회하는 것을 모두 배제
		* 회원이라는 `리소스`만 식별하면 됨 -> 회원 리소스를 URI에 매핑
- `URI 계층 구조`를 활용해야 함
	+ 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장(member -> members)
	+ 회원 조회/등록/수정/삭제를 모두 /members/{id}로 설계한다면 이를 어떻게 구분해야 하나
		* `URI는 리소스만 식별`
		* 리소스와 해당 리소스를 대상으로 하는 `행위를 분리`
			- `리소스` : 회원
			- `행위` : 조회, 등록, 삭제, 변경
			- `리소스는 명사, 행위는 동사`
			- 행위(메서드)를 구분하는 방법은 `HTTP 메서드`로 구분

<br/>

## HTTP 메서드
1. `GET`
	- 리소스 조회
2. `POST`
	- 요청 데이터 처리
	- 주로 등록에 사용
3. `PUT`
	- 리소스를 대체
	- 해당 리소스가 없으면 생성
	- 파일을 폴더에 넣은 것과 같음(있으면 덮어쓰고 없으면 넣어줌)
4. `PATCH`
	- 리소스 부분 변경
5. `DELETE`
	- 리소스 삭제
	- 회원 이름 변경 등 특정 필드 변경
6. HEAD
	- GET과 동일하지만 메세지 body 부분을 제외하고 상태줄과 헤더만 반환
7. OPTIONS
	- 대상 리소스에 대한 통신 기능 옵션(메서드)을 설명(주로 CORS에서 사용)
8. CONNECT
	- 대상 자원으로 식별되는 서버에 대한 터널을 설정
	- 거의 사용하지 않음
9. TRACE
	- 대상 리소스에 대한 경로를 따라 메세지 루프백 테스트를 수행
	- 거의 사용하지 않음

<br/>

### GET
- 리소스 `조회`
- 서버에 전달하고 싶은 데이터는 `query(쿼리 파라미터, 쿼리 스트링)`를 통해 전달
- 메세지 바디를 사용해서 데이터를 전달할 수 있지만 지원하지 않는 곳이 많아서 권장하지 않음
- 흐름
	1. `클라이언트`가 메세지를 서버에 전달
	2. `서버`에서 도착한 메세지를 까서 보내줄 데이터 생성(json 등등)
	3. 응답 메세지에 생성한 데이터를 넣어서 클라이언트에게 보내줌

<br/>

### POST
- `요청 데이터 처리`
- `대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청`
- 흐름
	1. 메세지 바디를 통해 서버로 `요청 데이터` 전달
		- 클라이언트와 서버 간에 '여기로 오면 등록할게!'라는 일종의 `약속` 필요
	2. 서버는 `요청 데이터를 처리`
		- 메세지 바디를 통해 들어온 `데이터를 처리하는 모든 기능을 수행`
		- 주로 전달된 데이터로 신규 리소스 등록, 변경된 프로세스를 바꾸는 경우 등에 사용
	3. 서버가 클라이언트에게 `응답 데이터`를 보내줌
		- 생성이면 HTTP 상태 201 Created
		- Location으로 자원의 신규 생성된 URI 정보를 보내줌
- 사용되는 기능
	+ HTML 양식에 입력된 필드와 같은 데이터 블록을 `데이터 처리 프로세스`에 제공
		* HTML FORM에 입력한 정보로 회원 가입, 주문 등에 사용
	+ 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메세지 게시
		* 게시판 글쓰기, 댓글 달기
	+ `서버가 아직 식별하지 않은 새 리소스 생성`
		* 신규 주문 생성, 신규 회원 생성
	+ `기존 자원에 데이터 추가`
		* 한 문서 끝에 내용 추가하기
	+ `요청 데이터 처리`
		* 단순히 데이터를 생성하거나 변경하는 것을 넘어서 `프로세스를 처리`해야 하는 경우
			- 주문에서 결제 완료-> 배달 시작 -> 배달 완료처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
		* POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음
			- POST /orders/{oderId}/start-delivery
				+ 컨트롤 URI
					* 리소스만으로 최대한 설계를 하되 어쩔 수 없는 부분은 컨트롤 URI로 설계
					* 동사 사용
	+ 다른 메서드로 처리하기 애매한 경우
		* GET 메서드를 사용할 때 JSON을 보내야 하는 경우 등등
- `이 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 함 -> 정해진 것이 없음`
- POST는 모든 것을 다 할 수 있지만 조회할 때는 GET이 유리(캐싱 등등)

<br/>

### PUT
- 리소스를 `대체`
	+ `리소스가 있으면 대체, 없으면 생성`
	+ 덮어버림
- 클라이언트가 리소스를 식별
	+ `클라이언트가 리소스 위치를 알고 URI 지정`
		* PUT /members/100
		* POST와의 차이점(POST /members)
- 흐름
	1. 클라이언트가 PUT /members/100 로 데이터를 보냄
	2. 서버에 /members/100가 있으면 대체, 없으면 신규 생성
- `데이터를 완전히 대체`
	+ 기존에 2개의 필드(username, age) 중 하나의 데이터만 보낸다면 하나의 데이터로만 완전히 대체됨
	+ 리소스를 수정하는 것이 아니라 `갈아치우는 것`

<br/>

### PATCH
- 리소스 `부분 변경`
	+ 기존에 2개의 필드(username, age) 중 하나의 데이터만 보낸다면 하나의 데이터만 수정됨
- 지원이 안되는 경우 존재
	+ 그럴 땐 POST 사용

<br/>

### DELETE
- 리소스 `제거`

<br/>

## HTTP 메서드의 속성
- `안전(Safe Methods)`
- `멱등(Idempotent Methods)`
- `캐시가능(Cacheable Methods)`

### 안전(Safe)
- 호출해도 리소스를 `변경하지 않는 것`
- `GET`은 단순히 조회만 해서 안전
- POST, PUT, PATCH, DELETE 등등 뭔가 바꾸는 것은 안전하지 않음
- 계속 호출 시 로그가 쌓이는 문제로 장애 발생?
	+ 안전은 해당 리소스만 고려하고 그런 부분까지 고려하지는 않음

<br/>

### 멱등(Idempotent)
- f(f(x)) = f(x)
- `몇번을 호출하든 결과가 같은 것`
- 멱등 메서드
	+ `GET` : 몇번을 조회하든 같은 결과 조회
	+ `PUT` : 결과를 대체. 똑같은 파일을 업로드하면 덮어쓰기 해서 항상 동일. 여러번 해도 최종 결과는 동일
	+ `DELETE` : 결과를 삭제. 여러번 삭제해도 결과는 동일
- POST는 멱등이 아님
	+ 두번 호출하면 같은 결제가 중복해서 발생 가능
- 활용
	+ `자동 복구 매커니즘`
		* 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때 클라이언트가 같은 요청을 다시 해도 되는지의 판단 근거
		* DELETE가 잘 수행되었는지 모르는 상태에서 또 DELETE해도 괜찮음
- `외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않음`
	+ 재요청 중간에 다른 곳에서 리소스를 변경해버림 -> 고려하지않음

<br/>

### 캐시가능(Cacheable)
- 큰 용량의 이미지를 요청 후 같은 요청 안하게 `로컬에 저장하고 있는 것`
- `GET, HEAD, POST, PATCH` 캐시 가능
	+ 실제로는 `GET, HEAD` 정도만 캐시로 사용
		* GET은 URL만 캐시키로 고려하면 되는데 POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하므로 구현이 쉽지 않음(body 안의 내용)








