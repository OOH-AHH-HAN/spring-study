# 스프링 DB 접근 기술

## H2 데이터베이스 설치

- 버전 : 1.4.200
- 설치 방법
	1. 홈페이지 접속 후 설치
	2. 해당 폴더로 이동(~/h2/bin)
	3. `ls -arnth`로 파일 확인
	4. `chmod 755 h2.sh` 로 권한 주기(최초만)
	5. `./h2.sh`로 실행
	6. 실행된 url 앞에 ip가 적혀있다면 `localhost`로 바꾸기
	7. JDBC url을 `jdbc:h2:~test`로 설정(최초만)
	8. connect
	9. 최상위에서 `~/test.mv.db`파일 존재 확인
	10. disconnected
	11. JDBC url을 `jdbc:h2:tcp://localhost/~/test`로 설정(첫번째 이후부터는 계속 이렇게 설정)
		- 소켓을 통해서 접근하므로 여러군데에서 접근이 가능하다.
	12. connect
		
<br/>

### 테이블 생성

`sql/ddl.sql`

```sql
drop table if exists member CASCADE;
create table member
(
    
    id   bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);

```
> `bigint` : java의 long과 같은 역할   
`generated by default as identity` : null값 넣으면 DB가 알아서 채워줌. autoincreament나 sequence와 같은 역할

<br/>

## 순수 JDBC

### 환경 설정

`build.gradle` -> jdbc, h2 데이터베이스 관련 라이브러리 추가

```
//자바가 DB와 연결할려면 JDBC 드라이버가 꼭 있어야 하는데 이것을 가지고 연동
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
//DB와 연결할 때 필요한 DB가 제공하는 클라이언트
runtimeOnly 'com.h2database:h2'
```



`resources/application.properties` -> 스프링부트 데이터베이스 연결 설정 추가

```
//jdbc url
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
//h2 db 사용
spring.datasource.driver.driver-class-name=org.h2.Driver
//스프링부트 2.4 이상은 꼭 추가해주어야 함(공백 제거)
spring.datasource.username=sa
```
> 이 정보를 저장하면 Spring이 DataSource라는 것을 저장해놓음

<br/>

### Jdbc 리포지터리 구현

- JDBC API로 직접 코딩하는 것은 20년 전 이야기
- 참고만 하기
<br/>

`java/practice/practicespring/repository/JdbcMemberRepository.java`


```java

package practice.practicespring.repository;

import org.springframework.jdbc.datasource.DataSourceUtils;
import practice.practicespring.domain.Member;

import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class JdbcMemberRepository implements MemberRepository {

    private final DataSource dataSource;

    //spring한테 주입받아야 함
    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public Member save(Member member) {
        String sql = "insert into member(name) values(?)";

        /*Connection conn = dataSource.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql);
        pstmt.setString(1, member.getName());
        pstmt.executeUpdate();*/

        Connection conn = null;
        PreparedStatement pstmt = null;   
	//결과 받기
        ResultSet rs = null;
        try {
            conn = getConnection();
	    //시퀀스 값 리턴 받을 것
            pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            pstmt.setString(1, member.getName());
            pstmt.executeUpdate();
	    //시퀀스 값 꺼내줌
            rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패");
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public Optional<Member> findById(Long id) {
        String sql = "select * from member where id = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, id);
	    //조회는 update 대신 execute
            rs = pstmt.executeQuery();
            if (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public List<Member> findAll() {
        String sql = "select * from member";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();
            List<Member> members = new ArrayList<>();
            while (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                members.add(member);
            }
            return members;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public Optional<Member> findByName(String name) {
        String sql = "select * from member where name = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, name);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            }
            return Optional.empty();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    //스프링 프레임워크 쓰려면 꼭 이 방식 써야함
    private Connection getConnection() {
	//이전에 tansaction connection 유지 가능
        return DataSourceUtils.getConnection(dataSource);
    }

    //역순으로 close
    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs) {
        try {
            if (rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (pstmt != null) {
                pstmt.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (conn != null) {
                close(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void close(Connection conn) throws SQLException {
        DataSourceUtils.releaseConnection(conn, dataSource);
    }
}

```

<br/>

#### 스프링 설정 변경

- 다른 코드 변경하지 않고도 설정만 변경하면 가능
<br/>


`java/practice/practicespring/SpringConfig.java`


```
package practice.practicespring;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import practice.practicespring.repository.JdbcMemberRepository;
import practice.practicespring.repository.MemberRepository;
import practice.practicespring.repository.MemoryMemberRepository;
import practice.practicespring.service.MemberService;

import javax.sql.DataSource;

@Configuration
public class SpringConfig {

    private final DataSource dataSource;

    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    //spring bean을 등록할 것이라는 의미
    //@Configuration을 읽고 @Bean을 보고 스프링 빈에 등록하라는 뜻이네! 한 다음에  메소드를 호출해 등록을 해줌
    //생성자
    @Bean
    public MemberService memberService() {

        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        //구현체 생성
        //인터페이스는 new가 안된다
        //return new MemoryMemberRepository();

        //나중에 db 연결 구현체로 바꿀때 여기만 바꿔주면 다른 소스들은 고칠 필요 없음
        //return mew DbMemberRepository();

	//다형성
        return new JdbcMemberRepository(dataSource);
    }
}
```

> `DataSurce` : 데이터베이스 커넥션을 획득할 때 사용하는 객체. 스프링부트는 커넥션 정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어 둠. 때문에 DI 가능.

> `MemberRepository interface를 구현 후 구현체만 변경하는 구조`    
   ->  조립하는 곳만 변경하면 다른 소스는 건들 필요가 없음


- `개방 폐쇄 원칙(OCP, Open-Closed Principle)`
	+ 확장에는 열려있고 수정,변경에는 닫혀있다
	+ 기존 코드는 변경하지 않으면서 기능을 추가하도록 설계해야 한다는 원칙
	+ 기능 추가 요청이 오면 클래스를 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야 하는 설계 기법

- `DI(Dependencies Injection)`을 사용하면 기존 코드를 전혀 손대지 않고 설정만으로 구현 클래스를 변경 가능


<br/>

## 스프링 통합 테스트
- 스프링 컨테이너와 DB 엮어서 테스트

<br/>

`java/practice/practicespring/service/MemberServiceIntegrationTest.java`

```java


package practice.practicespring.service;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;
import practice.practicespring.domain.Member;
import practice.practicespring.repository.MemberRepository;
import practice.practicespring.repository.MemoryMemberRepository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

//스프링 컨테이너와 테스트를 함께 실행
@SpringBootTest
//테스트 후에 롤백
@Transactional
class MemberServiceIntegrationTest {

    //가장 편리한 방법
    @Autowired MemberService memberService;
    @Autowired MemberRepository memberRepository;

    @Test
    void 회원가입 () {
        //given
        Member member = new Member();
        member.setName("hello");

        //when
        Long saveId = memberService.join(member);

        //then
        Member findMember = memberService.findOne(saveId).get();
        assertThat(member.getName()).isEqualTo(findMember.getName());
    }

    @Test
    public void 중복_회원_예외() {
        //given
        Member member = new Member();
        member.setName("spring");

        Member member2 = new Member();
        member2.setName("spring");

        //when
        memberService.join(member);

        IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));
        assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");

        //then
    }
}

```
- `transaction` : DB에 insert 쿼리 한 다음 commit 하기 전에는 반영이 안됨.
- `Transactional` 
	+ 테스트 케이스에 이 애노테이션이 있으면 테스트 시작 전에 트랜잭션을 시작하고 테스트 완료 후에 항상 롤백. 
	+ 테스트는 반복해야 하는데 데이터가 남아있으면 다음 테스트에 영향을 주므로 아예 반영을 안함. -> 반복 가능
	+ `BeforeEach`, `AfterEach`의 역할을 대신 해줌. 테스트 메소드
	+ 테스트 메소드마다 동작함
	+ 테스트 케이스에 붙었을 때만 롤백, 서비스나 다른 곳에 붙으면 정상 동작함.
- `@Commit` : 메소드에 사용시 해당 메소드가 끝나면 commit해버림.
- 테스트
	+ `단위 테스트` : 순수하게 자바 코드로 하면서 최소한의 단위로 하는 것
		* 훨씬 더 좋은 테스트일 확률이 높음
		* 속도 빠름
		* 이 방식으로 테스트 훈련을 해야 함
	+ `통합 테스트` : 스프링, DB 연동 테스트
	+ 보통 테스트용 DB를 따로 구축하거나 로컬 DB에서 테스트

<br/>

## 스프링 JdbcTemplate
- 라이브러리
- 실무에서 많이 사용
- 순수 Jdbc와 동일하게 환경 설정
- JDBC API에서 본 반복코드(resultset, connection 등등)를 대부분 제거해줌.(MyBatis도 마찬가지)
- SQL은 직접 작성해야 함

<br/>

`java/practice/practicespring/repository/JdbcTemplateMemberRepository.java`

```java

package practice.practicespring.repository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import practice.practicespring.domain.Member;

import javax.sql.DataSource;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

public class JdbcTemplateMemberRepository implements MemberRepository {

    public final JdbcTemplate jdbcTemplate;

    //생략 가능(생성자가 딱 하나 있으면)
    @Autowired
    //injection을 받을 수 있는 것은 아니므로 dataSource를 injection 받음
    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Member save(Member member) {
        //쿼리를 짤 필요가 없음
        //공식문서 보고 이용
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());
        Number key = jdbcInsert.executeAndReturnKey(new
                MapSqlParameterSource(parameters));
        member.setId(key.longValue());
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        //길고 복잡했던 코드를 단 2줄로 변환 가능
        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
        return result.stream().findAny();
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = jdbcTemplate.query("select * from member where name = ?", memberRowMapper(), name);
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return jdbcTemplate.query("select * from member", memberRowMapper());
    }

    private RowMapper<Member> memberRowMapper() {
        /*return new RowMapper<Member>() {
            @Override
            public Member mapRow(ResultSet rs, int rowNum) throws SQLException {

                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return member;
            }
        };*/

        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        };
    }
}
```


<br/>

`java/practice/practicespring/SpringConfig.java`

```java

package practice.practicespring;

import jakarta.persistence.EntityManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import practice.practicespring.aop.TimeTraceAop;
import practice.practicespring.repository.*;
import practice.practicespring.service.MemberService;

import javax.sql.DataSource;

@Configuration
public class SpringConfig {

    private DataSource dataSource;

    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    //spring bean을 등록할 것이라는 의미
    //@Configuration을 읽고 @Bean을 보고 스프링 빈에 등록하라는 뜻이네! 한 다음에  메소드를 호출해 등록을 해줌
    //생성자
    @Bean
    public MemberService memberService() {

        return new MemberService(memberRepository());

    }

    @Bean
    public MemberRepository memberRepository() {
        //구현체 생성
        //인터페이스는 new가 안된다
        //return new MemoryMemberRepository();

        //나중에 db 연결 구현체로 바꿀때 여기만 바꿔주면 다른 소스들은 고칠 필요 없음
        //return mew DbMemberRepository();

        //return new JdbcMemberRepository(dataSource);

        return new JdbcTemplateMemberRepository(dataSource);

         
    }
}
```

<br/>


- 스프링에서 다음과 같이 사용하는 것을 권장한다(아래 방식)

```java

public final JdbcTemplate jdbcTemplate;

@Autowired
public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }
```


<br/>

## JPA
- Java Persistence Api
- 기존의 반복되는 코드와 기본적인 SQL까지 JPA가 직접 만들어서 실행해줌
- 객체 중심의 설계로 패러다임 전환 가능
- 개발 생산성을 크게 향상시킬 수 있음

<br/>

`build.gradle`

```
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.0.0'
	id 'io.spring.dependency-management' version '1.1.0'
}

group = 'practice'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '17'

repositories {
	mavenCentral()
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	//implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	//이걸 적용하면 External Library에 jakarta.persistence-api(인터페이스), hibernate-core(구현체)가 설치되어져야 함
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	runtimeOnly 'com.h2database:h2'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') {
	useJUnitPlatform()
}
```
> `pring-boot-starter-data-jpa` : 내부에 jdbc 관련 라이브러리를 포함하므로 jdbc는 제거해도 됨.

<br/>

`resources/application.properties`

```
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver.driver-class-name=org.h2.Driver
spring.datasource.username=sa

//jpa가 날리는 sql을 출력 가능
spring.jpa.show-sql=true
//객체를 보고 자동으로 테이블을 생성해주는 기능(이미 테이블을 만들어놨기 때문에 끄고 실습)
//create로 바꾸면 테이블 자동 생성 가능
spring.jpa.hibernate.ddl-auto=none
```

<br/>


`java/practice/practicespring/domain/Member.java`


```java
package practice.practicespring.domain;

import jakarta.persistence.*;

//jpa가 관리하는 엔티티
@Entity
public class Member {

	//쿼리에 id를 넣는 것이 아니라 db가 자동으로 값을 넣어주는 것을 identity라고 함
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    //DB 컬럼명을 나타냄
    //@Column(name = "username")
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

<br/>

`java/practice/practicespring/repository/JpaMemberRepository.java`

```java
package practice.practicespring.repository;

import jakarta.persistence.EntityManager;
import practice.practicespring.domain.Member;

import java.util.List;
import java.util.Optional;

public class JpaMemberRepository implements MemberRepository{

    //spring이 만들어준 것으로 injection 받으면 됨
    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        //영구저장하다
        //jpa가 쿼리 만들고 id까지 넣어줌
        em.persist(member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
	//find(조회할 타입, pk)
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }

    @Override
    public Optional<Member> findByName(String name) {
	//spql 쿼리 언어
	//객체지향 쿼리 sql 써야 함
	//테이블 대상으로 쿼리를 날리는 것이 아니라 객체를 대상으로 쿼리를 날림(엔티티 대상)
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
    }
}


```

<br/>


`java/practice/practicespring/service/MemberService.java`

```java
import org.springframework.transaction.annotation.Transactional;

//service 안의 메소드 단위에 써도 가능
@Transactional
/*@Service*/
public class MemberService {

}
```
> 스프링은 해당 클래스의 메소드를 실행할 때 트랜잭션을 시작하고 메소드가 정상 종료되면 트랜잭션을 커밋.   
런타임 에러가 발생하면 롤백.

> JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 함

<br/>


`java/practice/practicespring/SpringConfig.java`

```java
package practice.practicespring;

import jakarta.persistence.EntityManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import practice.practicespring.aop.TimeTraceAop;
import practice.practicespring.repository.*;
import practice.practicespring.service.MemberService;

import javax.sql.DataSource;

@Configuration
public class SpringConfig {

    private DataSource dataSource;
    private EntityManager em;

    @Autowired
    public SpringConfig(DataSource dataSource, EntityManager em) {
        this.dataSource = dataSource;
        this.em = em;
    }

    @Bean
    public MemberService memberService() {

        return new MemberService(memberRepository()); 

    }

    @Bean
    public MemberRepository memberRepository() {
        //구현체 생성
        //인터페이스는 new가 안된다
        //return new MemoryMemberRepository();

        //나중에 db 연결 구현체로 바꿀때 여기만 바꿔주면 다른 소스들은 고칠 필요 없음
        //return mew DbMemberRepository();

        //return new JdbcMemberRepository(dataSource);

        //return new JdbcTemplateMemberRepository(dataSource);

        return new JpaMemberRepository(em);
    }
}
```

<br/>

## 스프링 데이터 JPA
- 리포지토리에 구현 클래스 없이 인터페이스만으로도 개발 완료 가능
- 반복 개발해온 기본 CRUD 기능도 스프링 데이터 JPA가 모두 제공
- 핵심 비즈니스 로직을 개발하는데 집중 가능
- 실무에서 관계형 데이터베이스를 사용한다면 데이터 JPA는 필수
- 스프링 데이터 JPA는 JPA를 편리하게 사용하도록 도와주는 도구 역할알 뽄이므로 먼저 JPA를 확실하게 알아야 함

> 앞의 JPA 설정을 그대로 사용

<br/>


`java/practice/practicespring/repository/SpringDataJpaMemberRepository.java`

```java
package practice.practicespring.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import practice.practicespring.domain.Member;

import java.util.Optional;

//interface가 interface를 받을 때는 implements가 아니라 extends를 사용
//JpaRepository<객체 타입, pk의 타입>
//interface는 다중 상속 가능
public interface SpringDataJpaMemberRepository extends JpaRepository<Member, Long >, MemberRepository {

    //JPQL select m from Member m where m.name = ?
    @Override
    Optional<Member> findByName(String name);

    //이런식으로 확장 가능(규칙존재)
    //Optional<Member> findByNameAndId(String name, Long Id);
}
```

<br/>

`java/practice/practicespring/SpringConfig.java`

```java
package practice.practicespring;

import jakarta.persistence.EntityManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import practice.practicespring.aop.TimeTraceAop;
import practice.practicespring.repository.*;
import practice.practicespring.service.MemberService;

import javax.sql.DataSource;

@Configuration
public class SpringConfig {

    private final MemberRepository memberRepository;

    @Autowired
    public SpringConfig(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    //생성자
    @Bean
    public MemberService memberService() {

        //return new MemberService(memberRepository());
        return new MemberService(memberRepository);

    }

    @Bean
    public MemberRepository memberRepository() {
        //구현체 생성
        //인터페이스는 new가 안된다
        //return new MemoryMemberRepository();

        //나중에 db 연결 구현체로 바꿀때 여기만 바꿔주면 다른 소스들은 고칠 필요 없음
        //return mew DbMemberRepository();

        //return new JdbcMemberRepository(dataSource);

        //return new JdbcTemplateMemberRepository(dataSource);

        return new JpaMemberRepository(em);
    }
}
```
> 스프링 데이터 JPA가 JpaRepository를 받고 있으면 구현체를 자동으로 만들어줘서 SpringDataJpaMemberRepository를 스프링 빈으로 자동 등록해준다.

- `CrudRepository`, `PagingAndSortingRepository`, `JpaRepository`에서 공통화해서 기본적으로 다. 제공해준다.   
	+ 인터페이스를 통한 기본적인 CRUD
	+ `findByName(), findByEmail()`처럼 메소드 이름만으로 조회 기능 제공
	+ 페이징 기능 제공

- JPA와 스프링 데이터 JPA를 기본으로 사용하고 복잡한 동적 쿼리는 Querydsl이라는 라이브러리 사용
	+ 쿼리를 자바 코드로 안전하게 작성 가능
	+ 동적 쿼리도 편리하게 작성 가능
	+ 보다 더 심화된 쿼리를 작성해야 한다면 JPA가 제공하는 네이티브 쿼리를 사용하거나 스프링 JdbcTemplate룰 사용하면 됨











































































