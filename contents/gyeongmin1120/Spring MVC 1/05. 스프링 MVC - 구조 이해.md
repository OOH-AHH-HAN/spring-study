# 스프링 MVC - 구조 이해

## 스프링 MVC 전체 구조

Section 4까지 만든 MVC 프레임워크 구조와 SpringMVC 구조는 이름만 다를 뿐 거의 같음.

![스프링 MVC 구조](https://user-images.githubusercontent.com/37259132/218027834-a171477c-fb0f-4472-8159-29a6143f545a.jpg)

- FrontController => DispatcherServlet
- handlerMappingMap => HandlerMapping
- MyHandlerAdapter => HandlerAdapter
- ModelView => ModelAndView
- viewResolver => ViewResolver(인터페이스 기반)
- MyView => View(인터페이스 기반)

<br/>

### DispatcherServlet
- 프론트 컨트롤러
- 스프링 MVC의 핵심
- 부모클래스에서 HttpServlet을 상속받아서 사용
	+ DispatcherServlet -> FrameworkServlet -> HttpServletBean -> HttpServlet
- 스프링 부트는 내장 WAS를 띄울 떄 DispatcherServlet을 서블릿으로 자동 등록하면서 모든 경로(urlPatterns="/")에 대해 매핑
- 서블릿이 호출 -> HttpServlet이 제공하는 service() 호출 -> ... -> DispatcherServlet.doDispatch()

`DispatcherServlet.doDispatch()`

```
protected void doDispatch(HttpServletRequest request, HttpServletResponse
  response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    ModelAndView mv = null;
// 1. 핸들러 조회
mappedHandler = getHandler(processedRequest); if (mappedHandler == null) {
        noHandlerFound(processedRequest, response);
return; }
//2.핸들러 어댑터 조회-핸들러를 처리할 수 있는 어댑터
HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
// 3. 핸들러 어댑터 실행 -> 4. 핸들러 어댑터를 통해 핸들러 실행 -> 5. ModelAndView 반환 mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    processDispatchResult(processedRequest, response, mappedHandler, mv,
  dispatchException);
}
  private void processDispatchResult(HttpServletRequest request,
  HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView
  mv, Exception exception) throws Exception {
          // 뷰 렌더링 호출
render(mv, request, response);
  }
  protected void render(ModelAndView mv, HttpServletRequest request,
  HttpServletResponse response) throws Exception {
    View view;
String viewName = mv.getViewName(); //6. 뷰 리졸버를 통해서 뷰 찾기,7.View 반환
    view = resolveViewName(viewName, mv.getModelInternal(), locale, request);
// 8. 뷰 렌더링
    view.render(mv.getModelInternal(), request, response);
  }
```

- 동작 순서
	1. 핸들러 조회(컨트롤러) : 요청 URL 뿐만 아니라 여러가지 정보 활용
	2. 핸들러 어댑터 조회
	3. 핸들러 어댑터 실행
	4. 핸들러 실행
	5. ModelAndView 반환 : 받아서 변환해서 반환
	6. viewResolver 호출 : 뷰 리졸버 찾고 실행
		+ jsp : InternalResourceViewResolver 자동 등록 및 사용
	7. View 반환 : 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고 렌더링 역할을 담당하는 뷰 객체를 반환
	8. 뷰 렌더링

> 스프링 MVC에는 대부분의 기능이 이미 다 구현되어 있음.   
어떤 부분에서 문제가 발생했는지 파악하고 확장 포인트가 필요할 때 감을 찾을 수 있음.   
전체적인 구조 이해하면 됨.   

<br/>
<br/>

## 핸들러 매핑과 핸들러 어댑터
- @Controller 사용 전에 사용했던 컨트롤러로 핸들러 매핑과 어댑터 이해해보자.

`java/hello/servlet/web/springmvc/old/OldController.java`

```java
package hello.servlet.web.springmvc.old;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//spring bean 이름
//spring bean으로 등록됨
@Component("/springmvc/old-controller")
public class OldController implements Controller {

    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        System.out.println("OldController.handleRequest");
        return null;
     }
}
```

<br/>

- HandlerMapping(핸들러 매핑)
	+ 0 = 애노테이션 기반 컨트롤러 @RequestMapping에서 사용 : RequestMappingHandlerMapping
	+ 1 = 스프링 빈의 이름으로 핸들러를 찾음 : `BeanNameUrlHandlerMapping`
-> 헨들러 반환 (스프링 빈으로 등록해놔서)

- HandlerAdapter(핸들러 어댑터)
	+ 0 = 애노테이션 기반 컨트롤러 @RequestMapping에서 사용 : RequestMappingHandlerAdapter
	+ 1 = HttpRequestHandler 처리 : HttpRequestHandlerAdapter
	+ 2 = Controller 인터페이스 : `SimpleControllerHandlerAdapter` 
-> 핸들러 호출 -> 결과 반환

> 거의 @ReqeustMapping 사용

<br/>
<br/>

## 뷰 리졸버

`java/hello/servlet/web/springmvc/old/OldController.java`

```java
package hello.servlet.web.springmvc.old;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//spring bean 이름
//spring bean으로 등록됨
@Component("/springmvc/old-controller")
public class OldController implements Controller {

    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        System.out.println("OldController.handleRequest");
        return new ModelAndView("new-form");
     }
}
```

<br/>

`resources/application.properties`

```
logging.level.org.apache.coyote.http11=debug

spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

<br/>

- 스프링 부트는 InternalResourceViewResolver 라는 뷰 리졸버를 자동으로 등록하는데 application.properties에 등록한 spring.mvc.view.prefix , spring.mvc.view.suffix 설정 정보를 사용해서 등록

`java/hello/servlet/ServletApplication.java`

```java
package hello.servlet;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletComponentScan;
import org.springframework.context.annotation.Bean;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

//서블릿 자동 등록 및 실행(패키지 밑에 있는 애들)
@ServletComponentScan
@SpringBootApplication
public class ServletApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServletApplication.class, args);
	}

	//이런식으로 spring boot가 알아서 해 줌.
	/*@Bean
	ViewResolver internalResourceViewResolver(){
		return new InternalResourceViewResolver("/WEB-INF/views/", ".jsp");
	}*/
}
```

<br/>

- 뷰 리졸버
	+ 1 = 빈 이름으로 뷰를 찾아서 반환 : BeanNameViewResolver
	+ 2 = JSP를 처리할 수 있는 뷰를 반환 : InternalResourceViewResolver
- 동작 방식
	1. 핸들러 어댑터 호출 : 논리 뷰 이름 획득
	2. ViewResolver 호출 : 스프링 빈으로 등록된 뷰를 찾는데 없으므로 InternalResourceViewResolver 호출
	3. InternalResourceViewResolver : InternalResourceView 반환. 내부에서 자원이 이동
		+ JSTL 라이브러리가 있으면 JstlView 반환(InternalResourceView 상속)
	4. 뷰 - InternalResourceView : JSP처럼 forward()를 호출해서 처리할 수 있는 경우에 사용
	5. view.render() 호출

<br/>
<br/>
